# 设计模式
软件设计的目标：复用性

## 如何解决复杂性
**分解**

> 就是将复杂的问题简单化，即分而治之。

**抽象**

> 去除非本质细节，而去处理泛化和理想化的对象模型，即抽象

## 面向对象五大设计原则(SOLID)

**1.单一职责原则(SRP:Single Responsibility Principle)**

- 一个类应该仅有一个引起它变化的原因

**2.开放封闭原则(OCP:Open Closed Principle)**

- 对扩展开放，对修改关闭

> 实现开放封闭原则的思想是：
> 1.抽象出相对稳定的接口，这部分不改动或者很少改动
> 2.封装变化

**3.里氏替换原则(LSP:Liskov Substitution Principle)**

- 所有引用基类的地方都可以使用其子类进行替换

> 通常设计的时候优先采用组合而不是继承，因为继承虽然减少了代码量，提高了代码的重用性，但是父类和子类有很强的耦合，破坏了封装

**4.接口隔离原则(ISP：Interface Segregation Principle)**

- 不应该强迫客户程序依赖它们不用的方法。
- 接口的设计应该遵循最小接口原则

权限修饰符的使用：public（所有），protected（所有子类包括本包及外包），default（仅限本包内的子类），private（本来使用）

**5.依赖导致原则(DIP)**

- 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）

> 实质就是针对接口编程，接口就是抽象

## 模版方法模式

**模式定义：定义一个操作中的算法的骨架（稳定），而将一些步骤（变化）延迟到子类中。
模版方法使得子类可以不改变一个算法的结构即可重定义（重写：override）该算法的某些特定步骤**

![模版方法.png](https://i.loli.net/2019/07/07/5d2196495174f39239.png)

## 策略模式

**模式定义：定义算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不影响使用算法的客户**

![策略模式.png](https://i.loli.net/2019/07/07/5d21d1ed9a1f435993.png)

1. 利用多态特性针对接口（超类型）编程，声明时类型是接口，运行时动态指定具体实现的对象
2. 利用组合特性（多用组合，少用集成），实现运行时动态绑定


## 观察者模式

**模式定义：定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。**

![观察者模式结构图](https://i.loli.net/2019/07/07/5d21e64cb171d24913.png)

JDK自己实现了一套观察者模式public class Observable类作为主题，public interface Observer的实现作为观察者对象。



## 装饰模式（Decorator）

  **抛出问题：**

**过度使用继承来扩展对象的功能，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各个子类的组合（扩展功能的组合）会导致更多子类的膨胀**

**模式定义：动态（组合）的给一个对象增加一些额外的职责。就增加功能而言，装饰模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）**

![装饰模式结构图](https://i.loli.net/2019/07/07/5d21f4748f22375290.png)

**模式总结**

- 通过采用组合而非继承的手法，装饰模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
- Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
- Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展功能“，其实就是”装饰“的含义。

**典型实例：Java I/O**

![JavaIO](https://i.loli.net/2019/07/20/5d32cf6628c1e42246.png)



## 桥模式（Bridge）

**模式定义：将抽象部分与实现部分分离，使它们都可以独立的变化**

 ![结构图](https://i.loli.net/2019/07/07/5d2203059959820655.png)

**模式总结**

- Bridge模式使得“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。
- Bridge模式有时类似于多继承方案，但是多继承方案往往违背单一职责原则，复用性比较差。Bridge模式是比多继承方案更好的解决方法。
- Bridge模式的应用一般在“两个非常强的变化维度“，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。

## 工厂方法模式（Factory Method）

**模式定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到子类**

![结构图](https://i.loli.net/2019/07/09/5d248f04aded112231.png)

**模式总结**

- Factory Methd模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。
- Factory Method模式

## 抽象工厂模式（Abstract Factory）

**模式定义：提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定他们具体的类。**

